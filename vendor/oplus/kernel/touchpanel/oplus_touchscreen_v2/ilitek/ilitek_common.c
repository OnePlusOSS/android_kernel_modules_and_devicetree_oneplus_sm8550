// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2018-2020 Oplus. All rights reserved.
 */

#include "ilitek_common.h"
#include <linux/module.h>

#ifdef TPD_DEVICE
#undef TPD_DEVICE
#define TPD_DEVICE "ilitek_common"
#else
#define TPD_DEVICE "ilitek_common"
#endif
/*************************************auto test Funtion**************************************/

/*step1: read limit fw data*/
static int ilitek_read_limit_fw(struct seq_file *s,
				struct black_gesture_test *p, struct touchpanel_data *ts,
				struct auto_testdata *ilitek_testdata)
{
	const struct firmware *fw = NULL;
	struct auto_test_header *test_head = NULL;
	uint32_t *p_data32 = NULL;

	TPD_INFO("%s: enter\n", __func__);
	fw = ts->com_test_data.limit_fw;
	/*step4: decode the limit image*/
	test_head = (struct auto_test_header *)fw->data;
	p_data32 = (uint32_t *)(fw->data + 16);

	if ((test_head->magic1 != Limit_MagicNum1)
			|| (test_head->magic2 != Limit_MagicNum2)) {
		TPD_INFO("limit image is not generated by oplus\n");

		if (s) {
			seq_printf(s, "limit image is not generated by oplus\n");
		}

		if (p) {
			snprintf(p->message, p->message_size - 1,
				 "limit image is not generated by oplus\n");
		}

		return  -1;
	}

	TPD_INFO("current test item: %llx\n", test_head->test_item);
	/*init ilitek_testdata*/
	ilitek_testdata->tx_num = ts->hw_res.tx_num;
	ilitek_testdata->rx_num = ts->hw_res.rx_num;
	ilitek_testdata->irq_gpio = ts->hw_res.irq_gpio;
	ilitek_testdata->tp_fw = ts->panel_data.tp_fw;
	/*auto test save result*/
	ilitek_testdata->fp = ts->com_test_data.result_data;
	ilitek_testdata->length = ts->com_test_data.result_max_len;
	ilitek_testdata->pos = &ts->com_test_data.result_cur_len;
	/*black screen save result*/
	ilitek_testdata->bs_fp = ts->com_test_data.bs_result_data;
	ilitek_testdata->bs_length = ts->com_test_data.bs_result_max_len;
	ilitek_testdata->bs_pos = &ts->com_test_data.bs_result_cur_len;

	ilitek_testdata->fw = fw;
	ilitek_testdata->test_item = test_head->test_item;

	return 0;
}

/*step2: test support item*/
static int ilitek_auto_test_item(struct seq_file *s, struct touchpanel_data *ts,
				 struct auto_testdata *ilitek_testdata)
{
	int error_count = 0;
	struct ilitek_test_operations *ilitek_test_ops = NULL;
	struct com_test_data *com_test_data_p = NULL;

	com_test_data_p = &ts->com_test_data;

	if (!com_test_data_p || !com_test_data_p->chip_test_ops) {
		TPD_INFO("%s: com_test_data is null\n", __func__);
		error_count++;
		goto END;
	}

	ilitek_test_ops = (struct ilitek_test_operations *)
			  com_test_data_p->chip_test_ops;

	if (!ilitek_test_ops->auto_test_preoperation) {
		TPD_INFO("not support gd_test_ops->auto_test_preoperation callback\n");

	} else {
		error_count += ilitek_test_ops->auto_test_preoperation(s, ts->chip_data,
				ilitek_testdata);
	}

END:
	return error_count;
}


/*step2: test support item*/
static int ilitek_black_test_item(struct black_gesture_test *p,
				  struct touchpanel_data *ts, struct auto_testdata *ilitek_testdata)
{
	int error_count = 0;
	struct ilitek_test_operations *ilitek_test_ops = NULL;
	struct com_test_data *com_test_data_p = NULL;

	com_test_data_p = &ts->com_test_data;

	if (!com_test_data_p || !com_test_data_p->chip_test_ops) {
		if (p->message_size >= 30) {
			snprintf(p->message, 30, "%d errors. %s", error_count, "com_test_data is null.");
		}

		TPD_INFO("%s: com_test_data is null\n", __func__);
		error_count++;
		goto END;
	}

	ilitek_test_ops = (struct ilitek_test_operations *)
			  com_test_data_p->chip_test_ops;

	if (!ilitek_test_ops->black_screen_preoperation) {
		TPD_INFO("not support gd_test_ops->auto_test_preoperation callback\n");

	} else {
		error_count += ilitek_test_ops->black_screen_preoperation(p->message,
				p->message_size, ts->chip_data, ilitek_testdata);
	}

END:

	if (p->message_size >= 20) {
		snprintf(p->message, 20, "%d errors. %s", error_count,
			 error_count ? "" : "All test passed.");
	}

	TPD_INFO("%d errors. %s\n", error_count, error_count ? "" : "All test passed.");
	return error_count;
}

int ilitek_auto_test(struct seq_file *s,  struct touchpanel_data *ts)
{
	struct auto_testdata ilitek_testdata = {
		.tx_num = 0,
		.rx_num = 0,
		.fp = NULL,
		.irq_gpio = -1,
		.tp_fw = 0,
		.fw = NULL,
		.test_item = 0,
	};
	int error_count = 0;
	int ret = 0;

	ret = ilitek_read_limit_fw(s, NULL, ts, &ilitek_testdata);

	if (ret) {
		error_count++;
		goto END;
	}

	error_count += ilitek_auto_test_item(s, ts, &ilitek_testdata);

END:
	seq_printf(s, "imageid = 0x%llx, deviceid = 0x%llx\n", ilitek_testdata.tp_fw,
		   ilitek_testdata.dev_tp_fw);
	seq_printf(s, "%d error(s). %s\n", error_count,
		   error_count ? "" : "All test passed.");
	TPD_INFO(" TP auto test %d error(s). %s\n", error_count,
		 error_count ? "" : "All test passed.");
	return error_count;
}
EXPORT_SYMBOL(ilitek_auto_test);

int ilitek_black_screen_test(struct black_gesture_test *p,
			     struct touchpanel_data *ts)
{
	struct auto_testdata ilitek_testdata = {
		.tx_num = 0,
		.rx_num = 0,
		.fp = NULL,
		.irq_gpio = -1,
		.tp_fw = 0,
		.fw = NULL,
		.test_item = 0,
	};
	int ret = 0;
	int error_count = 0;

	ret = ilitek_read_limit_fw(NULL, p, ts, &ilitek_testdata);

	if (ret) {
		error_count++;
		goto END;
	}

	error_count += ilitek_black_test_item(p, ts, &ilitek_testdata);
END:
	return error_count;
}
EXPORT_SYMBOL(ilitek_black_screen_test);

MODULE_DESCRIPTION("Ilitek Touchscreen Common Interface");
MODULE_LICENSE("GPL");
