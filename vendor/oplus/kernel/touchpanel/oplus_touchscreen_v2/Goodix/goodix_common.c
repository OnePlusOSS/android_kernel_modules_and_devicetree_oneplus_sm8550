// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (C) 2018-2020 Oplus. All rights reserved.
 */

#include <linux/module.h>
#include "goodix_common.h"

#ifdef TPD_DEVICE
#undef TPD_DEVICE
#define TPD_DEVICE "goodix_common"
#else
#define TPD_DEVICE "goodix_common"
#endif
/*************************************auto test Funtion**************************************/

/*step1: read limit fw data*/
static int goodix_read_limit_fw(struct seq_file *s, struct touchpanel_data *ts,
				struct auto_testdata *p_goodix_testdata)
{
	const struct firmware *fw = NULL;
	struct auto_test_header *test_head = NULL;
	uint32_t *p_data32 = NULL;

	TPD_INFO("%s: enter\n", __func__);
	fw = ts->com_test_data.limit_fw;
	/*step4: decode the limit image*/
	test_head = (struct auto_test_header *)fw->data;
	p_data32 = (uint32_t *)(fw->data + 16);

	if ((test_head->magic1 != Limit_MagicNum1)
			|| (test_head->magic2 != Limit_MagicNum2)) {
		TPD_INFO("limit image is not generated by oplus\n");
		seq_printf(s, "limit image is not generated by oplus\n");
		return  -1;
	}

	TPD_INFO("current test item: %llx\n", test_head->test_item);
	/*init goodix_testdata*/
	p_goodix_testdata->tx_num = ts->hw_res.tx_num;
	p_goodix_testdata->rx_num = ts->hw_res.rx_num;
	p_goodix_testdata->irq_gpio = ts->hw_res.irq_gpio;
	p_goodix_testdata->tp_fw = ts->panel_data.tp_fw;
	p_goodix_testdata->fp = ts->com_test_data.result_data;
	p_goodix_testdata->length = ts->com_test_data.result_max_len;
	p_goodix_testdata->fw = fw;
	p_goodix_testdata->test_item = test_head->test_item;
	p_goodix_testdata->pos = &ts->com_test_data.result_cur_len;
	return 0;
}

/*step2: test support item*/
static int goodix_test_item(struct seq_file *s, struct touchpanel_data *ts,
			    struct auto_testdata *p_goodix_testdata)
{
	int error_count = 0;
	int ret = 0;
	struct test_item_info *p_test_item_info = NULL;
	struct goodix_auto_test_operations *gd_test_ops = NULL;
	struct com_test_data *com_test_data_p = NULL;
	int support_item = 0;

	com_test_data_p = &ts->com_test_data;

	if (!com_test_data_p || !com_test_data_p->chip_test_ops) {
		TPD_INFO("%s: com_test_data is null\n", __func__);
		error_count++;
		goto END;
	}

	gd_test_ops = (struct goodix_auto_test_operations *)
		      com_test_data_p->chip_test_ops;

	if (!gd_test_ops->auto_test_preoperation) {
		TPD_INFO("not support gd_test_ops->auto_test_preoperation callback\n");

	} else {
		ret = gd_test_ops->auto_test_preoperation(s, ts->chip_data, p_goodix_testdata,
				p_test_item_info);

		if (ret < 0) {
			TPD_INFO("auto_test_preoperation failed\n");
			error_count++;
		}
	}

	if (gd_test_ops->test1) {
		p_test_item_info = get_test_item_info(p_goodix_testdata->fw, TYPE_TEST1);
		if (!p_test_item_info) {
			TPD_INFO("item: %d get_test_item_info fail\n", TYPE_TEST1);
		} else {
			ret = gd_test_ops->test1(s, ts->chip_data, p_goodix_testdata, p_test_item_info);
			if (ret < 0) {
				TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST1, ret);
				error_count++;
			}
			support_item++;
		}
		tp_kfree((void **)&p_test_item_info);
	}

	if (gd_test_ops->test2) {
		p_test_item_info = get_test_item_info(p_goodix_testdata->fw, TYPE_TEST2);
		if (!p_test_item_info) {
			TPD_INFO("item: %d get_test_item_info fail\n", TYPE_TEST2);
		} else {
			ret = gd_test_ops->test2(s, ts->chip_data, p_goodix_testdata, p_test_item_info);
			if (ret < 0) {
				TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST2, ret);
				error_count++;
			}
			support_item++;
		}
		tp_kfree((void **)&p_test_item_info);
	}

	if (gd_test_ops->test3) {
		p_test_item_info = get_test_item_info(p_goodix_testdata->fw, TYPE_TEST3);
		if (!p_test_item_info) {
			TPD_INFO("item: %d get_test_item_info fail\n", TYPE_TEST3);
		} else {
			ret = gd_test_ops->test3(s, ts->chip_data, p_goodix_testdata, p_test_item_info);
			if (ret < 0) {
				TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST3, ret);
				error_count++;
			}
			support_item++;
		}
		tp_kfree((void **)&p_test_item_info);
	}


	if (gd_test_ops->test4) {
		p_test_item_info = get_test_item_info(p_goodix_testdata->fw, TYPE_TEST4);
		if (!p_test_item_info) {
			TPD_INFO("item: %d get_test_item_info fail\n", TYPE_TEST4);
		} else {
			ret = gd_test_ops->test4(s, ts->chip_data, p_goodix_testdata, p_test_item_info);
			if (ret < 0) {
				TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST4, ret);
				error_count++;
			}
			support_item++;
		}
		tp_kfree((void **)&p_test_item_info);
	}

	if (gd_test_ops->test5) {
		p_test_item_info = get_test_item_info(p_goodix_testdata->fw, TYPE_TEST5);
		if (!p_test_item_info) {
			TPD_INFO("item: %d get_test_item_info fail\n", TYPE_TEST5);
		} else {
			ret = gd_test_ops->test5(s, ts->chip_data, p_goodix_testdata, p_test_item_info);
			if (ret < 0) {
				TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST5, ret);
				error_count++;
			}
			support_item++;
		}
		tp_kfree((void **)&p_test_item_info);
	}

	if (gd_test_ops->test6) {
		ret = gd_test_ops->test6(s, ts->chip_data, NULL, NULL);
		if (ret < 0) {
			TPD_INFO("test%d failed! ret is %d\n", TYPE_TEST6, ret);
			error_count++;
		}
	}

	if (!gd_test_ops->auto_test_endoperation) {
		TPD_INFO("not support gd_test_ops->auto_test_preoperation callback\n");

	} else {
		ret = gd_test_ops->auto_test_endoperation(s, ts->chip_data, p_goodix_testdata,
				p_test_item_info);

		if (ret < 0) {
			TPD_INFO("auto_test_endoperation failed\n");
			error_count++;
		}
	}

END:
	if (!support_item) {
		error_count++;
	}
	return error_count;
}

int goodix_auto_test(struct seq_file *s,  struct touchpanel_data *ts)
{
	struct auto_testdata goodix_testdata = {
		.tx_num = 0,
		.rx_num = 0,
		.fp = NULL,
		.pos = NULL,
		.irq_gpio = -1,
		.tp_fw = 0,
		.fw = NULL,
		.test_item = 0,
	};
	int error_count = 0;
	int ret = 0;

	ret = goodix_read_limit_fw(s, ts, &goodix_testdata);

	if (ret) {
		error_count++;
		goto END;
	}

	error_count += goodix_test_item(s, ts, &goodix_testdata);

END:
	seq_printf(s, "imageid = 0x%llx, deviceid = 0x%llx\n", goodix_testdata.tp_fw,
		   goodix_testdata.dev_tp_fw);
	seq_printf(s, "%d error(s). %s\n", error_count,
		   error_count ? "" : "All test passed.");
	TPD_INFO(" TP auto test %d error(s). %s\n", error_count,
		 error_count ? "" : "All test passed.");
	return error_count;
}
EXPORT_SYMBOL(goodix_auto_test);

/*proc/touchpanel/Goodix/config_version*/
static int goodix_config_read_func(struct seq_file *s, void *v)
{
	struct touchpanel_data *ts = s->private;
	struct goodix_proc_operations *goodix_ops;

	if (!ts) {
		return 0;
	}

	goodix_ops = (struct goodix_proc_operations *)(ts->private_data);

	if (!goodix_ops) {
		return 0;
	}

	if (!goodix_ops->goodix_config_info_read) {
		seq_printf(s, "Not support auto-test proc node\n");
		return 0;
	}

	disable_irq_nosync(ts->client->irq);
	mutex_lock(&ts->mutex);

	goodix_ops->goodix_config_info_read(s, ts->chip_data);

	mutex_unlock(&ts->mutex);
	enable_irq(ts->client->irq);
	return 0;
}

static int proc_data_config_version_read(struct seq_file *s, void *v)

{
	goodix_config_read_func(s, v);
	return 0;
}

static int goodix_config_version_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_data_config_version_read, PDE_DATA(inode));
}

DECLARE_PROC_OPS(goodix_config_version_proc_fops, goodix_config_version_open, seq_read, NULL, single_release);

int goodix_create_proc(struct touchpanel_data *ts,
		       struct goodix_proc_operations *goodix_ops)
{
	int ret = 0;
	struct proc_dir_entry *prEntry_tmp = NULL;

	ts->private_data = goodix_ops;

	/*show config and firmware id interface*/
	prEntry_tmp = proc_create_data("config_version", 0666, ts->prEntry_debug_tp,
				       &goodix_config_version_proc_fops, ts);

	if (prEntry_tmp == NULL) {
		ret = -ENOMEM;
		TPD_INFO("%s: Couldn't create proc entry, %d\n", __func__, __LINE__);
	}

	return ret;
}
EXPORT_SYMBOL(goodix_create_proc);

int goodix_remove_proc(struct touchpanel_data *ts)
{
	if (!ts) {
		return -EINVAL;
	}

	remove_proc_entry("config_version", ts->prEntry_debug_tp);
	return 0;
}
EXPORT_SYMBOL(goodix_remove_proc);

void goodix_print_differ(s16 *diff_buf, u32 diff_size, int tx, int rx)
{
	int ret = 0;
	int i, j;
	u8 *out_str;
	u32 out_size;

	if (diff_buf == NULL) {
		TPD_INFO("GT:%s:diff_buf is NULL\n", __func__);
		return;
	}

	out_size = (tx+rx)*5 + 1;
	out_str = kzalloc(out_size, GFP_KERNEL);
	if (out_str == NULL) {
		TPD_INFO("GT:%s:kmalloc error\n", __func__);
		return;
	}

	TPD_INFO("GT:%s:mutual diff start\n", __func__);
	for (i = 0; i < rx; ++i) {
		ret = 0;
		for (j = 0; j < tx; ++j) {
			ret += snprintf(out_str+ret, out_size - ret, "%5d", diff_buf[i*tx + j]);
		}
		TPD_INFO("[%2d]%s\n", i, out_str);
	}
	TPD_INFO("GT:%s:mutual diff end\n", __func__);

	TPD_INFO("GT:%s:self diff start\n", __func__);
	ret = 0;
	for (i = tx*rx; i < diff_size; ++i) {
		ret += snprintf(out_str + ret, out_size - ret, "%5d", diff_buf[i]);
	}
	TPD_INFO("%s\n", out_str);
	TPD_INFO("GT:%s:self diff end\n", __func__);

	kfree(out_str);
}
EXPORT_SYMBOL(goodix_print_differ);

MODULE_DESCRIPTION("Touchscreen Goodix Common Interface");
MODULE_LICENSE("GPL");
